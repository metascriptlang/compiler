// Token types and utilities for the MetaScript lexer

import { test, check, testGroup } from "std/testing";

export enum TokenKind {
	// Literals
	Number, BigInt, String, TemplateHead, TemplateMiddle, TemplateTail, TemplateNoSub,
	// Identifier
	Ident,
	// Operators
	Plus, Minus, Star, Slash, Percent, StarStar,
	Assign, PlusEq, MinusEq, StarEq, SlashEq, PercentEq,
	EqEq, EqEqEq, BangEq, BangEqEq,
	Lt, LtEq, Gt, GtEq,
	AmpAmp, PipePipe, Bang,
	Amp, Pipe, Caret, Tilde, LtLt, GtGt, GtGtGt,
	PlusPlus, MinusMinus,
	Question, QuestionQuestion, QuestionDot,
	Dot, DotDotDot, Arrow, PipeGt,
	LParen, RParen, LBrace, RBrace, LBracket, RBracket,
	Semicolon, Colon, Comma, At,
	// Keywords
	Break, Case, Catch, Class, Const, Continue, Debugger, Default, Delete, Do,
	Else, Enum, Export, Extends, False, Finally, For, Function,
	If, Import, In, Instanceof, Interface, Let, New, Null,
	Return, Super, Switch, This, Throw, True, Try, Typeof, Var, Void, While, With,
	Abstract, As, Asserts, Async, Await, Constructor, Declare, From, Get,
	Implements, Infer, Is, Keyof, Namespace, Never, Of,
	Private, Protected, Public, Readonly, Require, Set, Static, Type, Unknown, Yield,
	Match, When, Unreachable, Defer, Distinct, Move, Out, Macro, Extern, Quote,
	Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64,
	Float32, Float64, Int, Float, Double,
	// EOF
	Eof,
}

export interface Token {
	kind: TokenKind;
	value: string;
	line: number;
	column: number;
}

export function createToken(kind: TokenKind, tokenValue: string, lineNum: number): Token {
	return { kind: kind, value: tokenValue, line: lineNum, column: 0 };
}

export function formatToken(token: Token): string {
	return `[${tokenKindToString(token.kind)}: '${token.value}' at line ${token.line.toString()}]`;
}

// Map identifier string to keyword TokenKind (or Ident)
// Compiler generates FNV-1a hash table for 80+ string cases â€” O(1) lookup
export function identToKeyword(ident: string): TokenKind {
	return match (ident) {
		"break" => TokenKind.Break,
		"case" => TokenKind.Case,
		"catch" => TokenKind.Catch,
		"class" => TokenKind.Class,
		"const" => TokenKind.Const,
		"continue" => TokenKind.Continue,
		"debugger" => TokenKind.Debugger,
		"default" => TokenKind.Default,
		"delete" => TokenKind.Delete,
		"do" => TokenKind.Do,
		"else" => TokenKind.Else,
		"enum" => TokenKind.Enum,
		"export" => TokenKind.Export,
		"extends" => TokenKind.Extends,
		"false" => TokenKind.False,
		"finally" => TokenKind.Finally,
		"for" => TokenKind.For,
		"function" => TokenKind.Function,
		"if" => TokenKind.If,
		"import" => TokenKind.Import,
		"in" => TokenKind.In,
		"instanceof" => TokenKind.Instanceof,
		"interface" => TokenKind.Interface,
		"let" => TokenKind.Let,
		"new" => TokenKind.New,
		"null" => TokenKind.Null,
		"return" => TokenKind.Return,
		"super" => TokenKind.Super,
		"switch" => TokenKind.Switch,
		"this" => TokenKind.This,
		"throw" => TokenKind.Throw,
		"true" => TokenKind.True,
		"try" => TokenKind.Try,
		"typeof" => TokenKind.Typeof,
		"var" => TokenKind.Var,
		"void" => TokenKind.Void,
		"while" => TokenKind.While,
		"with" => TokenKind.With,
		"abstract" => TokenKind.Abstract,
		"as" => TokenKind.As,
		"asserts" => TokenKind.Asserts,
		"async" => TokenKind.Async,
		"await" => TokenKind.Await,
		"constructor" => TokenKind.Constructor,
		"declare" => TokenKind.Declare,
		"from" => TokenKind.From,
		"get" => TokenKind.Get,
		"implements" => TokenKind.Implements,
		"infer" => TokenKind.Infer,
		"is" => TokenKind.Is,
		"keyof" => TokenKind.Keyof,
		"namespace" => TokenKind.Namespace,
		"never" => TokenKind.Never,
		"of" => TokenKind.Of,
		"private" => TokenKind.Private,
		"protected" => TokenKind.Protected,
		"public" => TokenKind.Public,
		"readonly" => TokenKind.Readonly,
		"require" => TokenKind.Require,
		"set" => TokenKind.Set,
		"static" => TokenKind.Static,
		"type" => TokenKind.Type,
		"unknown" => TokenKind.Unknown,
		"yield" => TokenKind.Yield,
		"match" => TokenKind.Match,
		"when" => TokenKind.When,
		"unreachable" => TokenKind.Unreachable,
		"defer" => TokenKind.Defer,
		"distinct" => TokenKind.Distinct,
		"move" => TokenKind.Move,
		"out" => TokenKind.Out,
		"macro" => TokenKind.Macro,
		"extern" => TokenKind.Extern,
		"quote" => TokenKind.Quote,
		"int8" => TokenKind.Int8,
		"int16" => TokenKind.Int16,
		"int32" => TokenKind.Int32,
		"int64" => TokenKind.Int64,
		"uint8" => TokenKind.Uint8,
		"uint16" => TokenKind.Uint16,
		"uint32" => TokenKind.Uint32,
		"uint64" => TokenKind.Uint64,
		"float32" => TokenKind.Float32,
		"float64" => TokenKind.Float64,
		"int" => TokenKind.Int,
		"float" => TokenKind.Float,
		"double" => TokenKind.Double,
		_ => TokenKind.Ident,
	};
}

// Map TokenKind enum to display string (match on enum -> C switch)
export function tokenKindToString(kind: TokenKind): string {
	return match (kind) {
		TokenKind.Number => "NUMBER",
		TokenKind.BigInt => "BIGINT",
		TokenKind.String => "STRING",
		TokenKind.TemplateHead => "TEMPLATE_HEAD",
		TokenKind.TemplateMiddle => "TEMPLATE_MIDDLE",
		TokenKind.TemplateTail => "TEMPLATE_TAIL",
		TokenKind.TemplateNoSub => "TEMPLATE_NOSUB",
		TokenKind.Ident => "IDENT",
		TokenKind.Plus => "PLUS",
		TokenKind.Minus => "MINUS",
		TokenKind.Star => "STAR",
		TokenKind.Slash => "SLASH",
		TokenKind.Percent => "PERCENT",
		TokenKind.StarStar => "STAR_STAR",
		TokenKind.Assign => "ASSIGN",
		TokenKind.PlusEq => "PLUS_EQ",
		TokenKind.MinusEq => "MINUS_EQ",
		TokenKind.StarEq => "STAR_EQ",
		TokenKind.SlashEq => "SLASH_EQ",
		TokenKind.PercentEq => "PERCENT_EQ",
		TokenKind.EqEq => "EQ_EQ",
		TokenKind.EqEqEq => "EQ_EQ_EQ",
		TokenKind.BangEq => "BANG_EQ",
		TokenKind.BangEqEq => "BANG_EQ_EQ",
		TokenKind.Lt => "LT",
		TokenKind.LtEq => "LT_EQ",
		TokenKind.Gt => "GT",
		TokenKind.GtEq => "GT_EQ",
		TokenKind.AmpAmp => "AMP_AMP",
		TokenKind.PipePipe => "PIPE_PIPE",
		TokenKind.Bang => "BANG",
		TokenKind.Amp => "AMP",
		TokenKind.Pipe => "PIPE",
		TokenKind.Caret => "CARET",
		TokenKind.Tilde => "TILDE",
		TokenKind.LtLt => "LT_LT",
		TokenKind.GtGt => "GT_GT",
		TokenKind.GtGtGt => "GT_GT_GT",
		TokenKind.PlusPlus => "PLUS_PLUS",
		TokenKind.MinusMinus => "MINUS_MINUS",
		TokenKind.Question => "QUESTION",
		TokenKind.QuestionQuestion => "QUESTION_QUESTION",
		TokenKind.QuestionDot => "QUESTION_DOT",
		TokenKind.Dot => "DOT",
		TokenKind.DotDotDot => "DOT_DOT_DOT",
		TokenKind.Arrow => "ARROW",
		TokenKind.PipeGt => "PIPE_GT",
		TokenKind.LParen => "LPAREN",
		TokenKind.RParen => "RPAREN",
		TokenKind.LBrace => "LBRACE",
		TokenKind.RBrace => "RBRACE",
		TokenKind.LBracket => "LBRACKET",
		TokenKind.RBracket => "RBRACKET",
		TokenKind.Semicolon => "SEMICOLON",
		TokenKind.Colon => "COLON",
		TokenKind.Comma => "COMMA",
		TokenKind.At => "AT",
		TokenKind.Break => "BREAK",
		TokenKind.Case => "CASE",
		TokenKind.Catch => "CATCH",
		TokenKind.Class => "CLASS",
		TokenKind.Const => "CONST",
		TokenKind.Continue => "CONTINUE",
		TokenKind.Debugger => "DEBUGGER",
		TokenKind.Default => "DEFAULT",
		TokenKind.Delete => "DELETE",
		TokenKind.Do => "DO",
		TokenKind.Else => "ELSE",
		TokenKind.Enum => "ENUM",
		TokenKind.Export => "EXPORT",
		TokenKind.Extends => "EXTENDS",
		TokenKind.False => "FALSE",
		TokenKind.Finally => "FINALLY",
		TokenKind.For => "FOR",
		TokenKind.Function => "FUNCTION",
		TokenKind.If => "IF",
		TokenKind.Import => "IMPORT",
		TokenKind.In => "IN",
		TokenKind.Instanceof => "INSTANCEOF",
		TokenKind.Interface => "INTERFACE",
		TokenKind.Let => "LET",
		TokenKind.New => "NEW",
		TokenKind.Null => "NULL",
		TokenKind.Return => "RETURN",
		TokenKind.Super => "SUPER",
		TokenKind.Switch => "SWITCH",
		TokenKind.This => "THIS",
		TokenKind.Throw => "THROW",
		TokenKind.True => "TRUE",
		TokenKind.Try => "TRY",
		TokenKind.Typeof => "TYPEOF",
		TokenKind.Var => "VAR",
		TokenKind.Void => "VOID",
		TokenKind.While => "WHILE",
		TokenKind.With => "WITH",
		TokenKind.Abstract => "ABSTRACT",
		TokenKind.As => "AS",
		TokenKind.Asserts => "ASSERTS",
		TokenKind.Async => "ASYNC",
		TokenKind.Await => "AWAIT",
		TokenKind.Constructor => "CONSTRUCTOR",
		TokenKind.Declare => "DECLARE",
		TokenKind.From => "FROM",
		TokenKind.Get => "GET",
		TokenKind.Implements => "IMPLEMENTS",
		TokenKind.Infer => "INFER",
		TokenKind.Is => "IS",
		TokenKind.Keyof => "KEYOF",
		TokenKind.Namespace => "NAMESPACE",
		TokenKind.Never => "NEVER",
		TokenKind.Of => "OF",
		TokenKind.Private => "PRIVATE",
		TokenKind.Protected => "PROTECTED",
		TokenKind.Public => "PUBLIC",
		TokenKind.Readonly => "READONLY",
		TokenKind.Require => "REQUIRE",
		TokenKind.Set => "SET",
		TokenKind.Static => "STATIC",
		TokenKind.Type => "TYPE",
		TokenKind.Unknown => "UNKNOWN",
		TokenKind.Yield => "YIELD",
		TokenKind.Match => "MATCH",
		TokenKind.When => "WHEN",
		TokenKind.Unreachable => "UNREACHABLE",
		TokenKind.Defer => "DEFER",
		TokenKind.Distinct => "DISTINCT",
		TokenKind.Move => "MOVE",
		TokenKind.Out => "OUT",
		TokenKind.Macro => "MACRO",
		TokenKind.Extern => "EXTERN",
		TokenKind.Quote => "QUOTE",
		TokenKind.Int8 => "INT8",
		TokenKind.Int16 => "INT16",
		TokenKind.Int32 => "INT32",
		TokenKind.Int64 => "INT64",
		TokenKind.Uint8 => "UINT8",
		TokenKind.Uint16 => "UINT16",
		TokenKind.Uint32 => "UINT32",
		TokenKind.Uint64 => "UINT64",
		TokenKind.Float32 => "FLOAT32",
		TokenKind.Float64 => "FLOAT64",
		TokenKind.Int => "INT",
		TokenKind.Float => "FLOAT",
		TokenKind.Double => "DOUBLE",
		TokenKind.Eof => "EOF",
		_ => "UNKNOWN_TOKEN",
	};
}

// ===== Token Tests =====

testGroup("Token Utilities", () => {
	test("identToKeyword const", () => { check(identToKeyword("const") === TokenKind.Const); });
	test("identToKeyword let", () => { check(identToKeyword("let") === TokenKind.Let); });
	test("identToKeyword ident", () => { check(identToKeyword("notAKeyword") === TokenKind.Ident); });
	test("identToKeyword underscore", () => { check(identToKeyword("_private") === TokenKind.Ident); });
	test("kindToString Plus", () => { check(tokenKindToString(TokenKind.Plus) === "PLUS"); });
	test("kindToString Eof", () => { check(tokenKindToString(TokenKind.Eof) === "EOF"); });
	test("kindToString Const", () => { check(tokenKindToString(TokenKind.Const) === "CONST"); });
});
